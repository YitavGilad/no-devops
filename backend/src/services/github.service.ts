import { Octokit } from '@octokit/rest';
import type { CreateRepoParams, CreateRepoResponse } from '../types/github.types';
import { TemplateService } from './template.service';
import { FrameworkService } from './framework.service';
import fs from 'fs-extra';
import path from 'path';

export class GitHubService {
  private octokit: Octokit;
  private username: string;

  private templateService: TemplateService;
  private frameworkService: FrameworkService;

  constructor(token: string, username: string) {
    console.log('Initializing GitHub service with username:', username);
    if (!token) {
      console.error('No GitHub token provided');
      throw new Error('GitHub token is required');
    }
    this.octokit = new Octokit({
      auth: token
    });
    this.username = username;
    this.templateService = new TemplateService();
    this.frameworkService = new FrameworkService();
  }

  async createRepository(params: CreateRepoParams): Promise<CreateRepoResponse> {
    // Verify GitHub token is valid
    try {
      const { data: user } = await this.octokit.users.getAuthenticated();
      console.log('Authenticated as GitHub user:', user.login);
    } catch (error) {
      console.error('Failed to authenticate with GitHub:', error);
      return {
        success: false,
        error: 'Invalid GitHub token or insufficient permissions'
      };
    }
    try {
      // Create the repository
      const { data: repo } = await this.octokit.repos.createForAuthenticatedUser({
        name: params.name,
        description: params.description || `A ${params.framework} project generated by Vibe Coding Generator`,
        private: params.private ?? true,
        auto_init: true
      });

      // Add initial files based on framework
      await this.initializeRepository(repo.name, params);

      return {
        success: true,
        data: {
          id: repo.id,
          name: repo.name,
          fullName: repo.full_name,
          url: repo.html_url,
          cloneUrl: repo.clone_url,
          private: repo.private,
          createdAt: repo.created_at
        }
      };
    } catch (error: any) {
      console.error('GitHub API error:', error?.response?.data || error.message);
      return {
        success: false,
        error: error.message || 'Failed to create repository'
      };
    }
  }

  private async initializeRepository(repoName: string, params: CreateRepoParams): Promise<void> {
    // Initialize with basic files
    const files = [
      {
        path: 'README.md',
        content: this.generateReadme(params),
        message: 'Initial commit: Add README.md'
      },
      {
        path: '.gitignore',
        content: this.generateGitignore(params.language),
        message: 'Add .gitignore'
      }
    ];

    // Get all template files from the framework's template directory
    const templateDir = path.join(
      this.templateService.getTemplatesDir(),
      params.language,
      params.framework
    );

    // Walk through all files in the template directory
    const templateFiles = fs.readdirSync(templateDir, { recursive: true });
    for (const file of templateFiles) {
      const filePath = path.join(templateDir, file.toString());
      const stats = fs.statSync(filePath);
      
      // Skip directories, we only want files
      if (stats.isDirectory()) continue;

      // Get the relative path from the template directory
      const relativePath = path.relative(templateDir, filePath);
      
      // Read the file content
      const content = fs.readFileSync(filePath, 'utf-8');
      
      files.push({
        path: relativePath,
        content,
        message: `Add ${relativePath}`
      });
    }

    // Add framework-specific files
    const packageJson = this.frameworkService.generatePackageJson(params);
    if (packageJson) {
      files.push({
        path: 'package.json',
        content: packageJson,
        message: 'Add package.json'
      });
    }

    const requirementsTxt = this.frameworkService.generateRequirementsTxt(params);
    if (requirementsTxt) {
      files.push({
        path: 'requirements.txt',
        content: requirementsTxt,
        message: 'Add requirements.txt'
      });
    }

    const pomXml = this.frameworkService.generatePomXml(params);
    if (pomXml) {
      files.push({
        path: 'pom.xml',
        content: pomXml,
        message: 'Add pom.xml'
      });
    }

    const buildGradle = this.frameworkService.generateBuildGradle(params);
    if (buildGradle) {
      files.push({
        path: 'build.gradle',
        content: buildGradle,
        message: 'Add build.gradle'
      });
    }

    // Create all files in parallel
    await Promise.all(files.map(file => 
      this.octokit.repos.createOrUpdateFileContents({
        owner: this.username,
        repo: repoName,
        path: file.path,
        message: file.message,
        content: Buffer.from(file.content).toString('base64')
      })
    ));
  }

  private generateReadme(params: CreateRepoParams): string {
    return `# ${params.name}

A ${params.framework} project generated by Vibe Coding Generator.

## Technology Stack

- Language: ${params.language}
- Framework: ${params.framework}

## Getting Started

1. Clone the repository
\`\`\`bash
git clone https://github.com/${this.username}/${params.name}.git
cd ${params.name}
\`\`\`

2. Install dependencies
\`\`\`bash
${params.language === 'javascript' ? 'npm install' : 
  params.language === 'python' ? 'pip install -r requirements.txt' :
  'mvn install'}
\`\`\`

3. Run the development server
\`\`\`bash
${params.language === 'javascript' ? 'npm run dev' :
  params.language === 'python' ? 'python main.py' :
  './mvnw spring-boot:run'}
\`\`\`
`;
  }

  private generateGitignore(language: string): string {
    const commonIgnores = [
      '.DS_Store',
      '.env',
      '.env.local',
      '.env.*.local',
      '*.log',
      'logs/',
      'dist/',
      'coverage/',
      '.idea/',
      '.vscode/'
    ];

    const languageSpecificIgnores: Record<string, string[]> = {
      javascript: [
        'node_modules/',
        'npm-debug.log*',
        'yarn-debug.log*',
        'yarn-error.log*',
        '.next/',
        'build/',
        '.cache/'
      ],
      python: [
        '__pycache__/',
        '*.py[cod]',
        '*$py.class',
        '*.so',
        '.Python',
        'env/',
        'venv/',
        'ENV/',
        'build/',
        'develop-eggs/',
        'downloads/',
        'eggs/',
        '.eggs/',
        'lib/',
        'lib64/',
        'parts/',
        'sdist/',
        'var/',
        '*.egg-info/',
        '.installed.cfg',
        '*.egg'
      ],
      java: [
        'target/',
        '*.class',
        '*.jar',
        '*.war',
        '*.ear',
        '*.logs',
        '.project',
        '.classpath',
        '.settings/',
        'bin/',
        '.gradle/'
      ]
    };

    return [...commonIgnores, ...(languageSpecificIgnores[language] || [])]
      .join('\n');
  }

  private generateWorkflow(params: CreateRepoParams): string {
    return this.templateService.getWorkflow(params);
  }
}
